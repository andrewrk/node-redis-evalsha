// Generated by CoffeeScript 1.6.2
(function() {
  var Shavaluator, async, redisClient, should, testHelper, _;

  _ = require('underscore');

  async = require('async');

  should = require('should');

  Shavaluator = require('../lib/shavaluator');

  testHelper = require('./test_helper');

  redisClient = null;

  describe('Shavaluator', function() {
    before(function() {
      return redisClient = testHelper.getRedisClient();
    });
    beforeEach(function(done) {
      this.shavaluator = new Shavaluator(redisClient);
      return async.parallel([
        function(cb) {
          return redisClient.flushdb(cb);
        }, function(cb) {
          return redisClient.send_command('script', ['flush'], cb);
        }
      ], done);
    });
    it('should pass an error if the script was never added', function(done) {
      return this.shavaluator["eval"]('nonexistent', function(err, result) {
        err.message.should.match(/not added/);
        return done();
      });
    });
    describe('_parseEvalParams()/eval() syntax', function() {
      before(function(done) {
        this.paramsAsObject = {
          keys: ['key1', 'key2'],
          args: ['arg1', 'arg2']
        };
        this.paramsAsArray = [2, 'key1', 'key2', 'arg1', 'arg2'];
        this.callbackParam = function() {};
        return done();
      });
      describe('object syntax', function() {
        it('should create an array from object hashes', function(done) {
          var parsed, _ref;

          parsed = Shavaluator._parseEvalParams(this.paramsAsObject);
          parsed.params.should.eql(this.paramsAsArray);
          if ((_ref = parsed.callback) != null) {
            _ref.should.be["false"]();
          }
          return done();
        });
        it('should include a callback in the return value if provided', function(done) {
          var parsed;

          parsed = Shavaluator._parseEvalParams(this.paramsAsObject, this.callbackParam);
          parsed.params.should.eql(this.paramsAsArray);
          parsed.callback.should.eql(this.callbackParam);
          return done();
        });
        return it('should accept non-array keys and arguments', function(done) {
          var parsed;

          parsed = Shavaluator._parseEvalParams({
            keys: 'key',
            args: 'arg'
          });
          parsed.params.should.eql([1, 'key', 'arg']);
          return done();
        });
      });
      describe('single-array syntax', function() {
        it('should pass through single-array parameters', function(done) {
          var parsed, _ref;

          parsed = Shavaluator._parseEvalParams(this.paramsAsArray);
          parsed.params.should.eql(this.paramsAsArray);
          if ((_ref = parsed.callback) != null) {
            _ref.should.be["false"]();
          }
          return done();
        });
        return it('should include a callback in the return value if provided', function(done) {
          var parsed;

          parsed = Shavaluator._parseEvalParams(this.paramsAsArray, this.callbackParam);
          parsed.params.should.eql(this.paramsAsArray);
          parsed.callback.should.eql(this.callbackParam);
          return done();
        });
      });
      return describe('direct-params-style syntax', function() {
        it('should convert direct params to an array', function(done) {
          var parsed, _ref;

          parsed = Shavaluator._parseEvalParams.apply(Shavaluator, this.paramsAsArray);
          parsed.params.should.eql(this.paramsAsArray);
          if ((_ref = parsed.callback) != null) {
            _ref.should.be["false"]();
          }
          return done();
        });
        return it('should include a callback in the return value if provided', function(done) {
          var parsed;

          parsed = Shavaluator._parseEvalParams.apply(Shavaluator, this.paramsAsArray.concat(this.callbackParam));
          parsed.params.should.eql(this.paramsAsArray);
          parsed.callback.should.eql(this.callbackParam);
          return done();
        });
      });
    });
    describe('add()', function() {
      return it('binds methods for scripts', function(done) {
        this.shavaluator.add({
          foobar: "not a valid script"
        });
        _.isFunction(this.shavaluator.foobar).should.eql(true);
        return done();
      });
    });
    return describe('eval()', function() {
      beforeEach(function(done) {
        this.shavaluator.add({
          echo: 'return ARGV[1]',
          luaget: "return redis.call('GET', KEYS[1])",
          setnxget: "redis.call('SETNX', KEYS[1], ARGV[1]); return redis.call('GET', KEYS[1]);"
        });
        return done();
      });
      it('evaluates scripts with arguments', function(done) {
        return this.shavaluator.echo({
          args: 'testValue'
        }, function(err, result) {
          if (err != null) {
            err.should.be["false"]();
          }
          result.should.eql('testValue');
          return done();
        });
      });
      it('runs the same script multiple times', function(done) {
        var i, samples, _fn, _i,
          _this = this;

        samples = [];
        _fn = function(i) {
          return samples.push(function(cb) {
            return _this.shavaluator.echo({
              args: "test" + i
            }, function(err, result) {
              if (err != null) {
                err.should.be["false"]();
              }
              result.should.eql("test" + i);
              return cb();
            });
          });
        };
        for (i = _i = 0; _i <= 10; i = ++_i) {
          _fn(i);
        }
        return async.waterfall(samples, done);
      });
      it('evaluates scripts with keys', function(done) {
        redisClient.set('testKey', 'testValue');
        return this.shavaluator.luaget({
          keys: 'testKey'
        }, function(err, result) {
          if (err != null) {
            err.should.be["false"]();
          }
          result.should.eql('testValue');
          return done();
        });
      });
      return it('evaluates scripts with both keys and arguments', function(done) {
        var t;

        t = Date.now().toString();
        return this.shavaluator.setnxget({
          keys: ['hey'],
          args: [t]
        }, function(err, result) {
          if (err != null) {
            err.should.be["false"]();
          }
          result.should.eql(t);
          return done();
        });
      });
    });
  });

}).call(this);
